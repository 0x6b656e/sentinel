### ---- CHECK NAME UNIQUENESS -----
if PeeWeeGovernanceObject.object_with_name_exists(args.proposal_name):
    print "governance object with that name already exists"
    return

newObj = GovernanceObject()
newObj.init(
  parent_id = 0,
  object_parent_hash = 0,
  object_name = proposal_name,
  object_type = govtypes.proposal,
  object_revision = govtypes.FIRST_REVISION
)
last_id = newObj.save()

if last_id != None:

    # ADD OUR PROPOSAL AS A SUB-OBJECT WITHIN GOVERNANCE OBJECT
    pw_proposal = PeeWeeProposal(
        governance_object_id = last_id,
        proposal_name = args.proposal_name,
        description_url = args.description_url,
        start_epoch = start_epoch,
        end_epoch = end_epoch,
        payment_address = args.payment_address,
        payment_amount = args.payment_amount
    )

    # APPEND TO GOVERNANCE OBJECT
    newObj.add_subclass("proposal", pw_proposal)
    newObj.save()

    # CREATE EVENT TO TALK TO DASHD / PREPARE / SUBMIT OBJECT
    pwevent = PeeWeeEvent()
    pwevent.governance_object_id = last_id
    pwevent.save()

    # NGM/TODO:  I think it's easier to have autocommit on and only
    # disable for specific transaction sequences which have to be
    # atomic, and all at once and encapsulated so that it's easy to
    # see the logic.
    # PeeWeeEvent._meta.database.commit()

    print "event queued successfully"
else:
    print "error: Could not save GovernanceObject"

    # PeeWeeEvent._meta.database.rollback()
    # abort mysql commit

return
